
==================== FINAL INTERFACE ====================
2016-04-08 11:05:53.018129 UTC

interface homew_Dsxa3cMcnlM9wFO6qD9wN0:Lib 7103
  interface hash: a3c450c6aa712a5e76f816f5523dbbf2
  ABI hash: fa23060b07d7f1376eb2c271ffe83021
  export-list hash: 90a062f70d5e5549b3173f4f48afcd34
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a729319f406451ebd33a50da2b420fc1
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.coPrime
  Lib.gcd
  Lib.gcfList
  Lib.list2_1
  Lib.perfect
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 37c1dcdf6448d7800d277e5be0c3fc6f
import  -/  base-4.8.2.0:GHC.Base bf56e93e483b6a281ad97fedb63bfd04
import  -/  base-4.8.2.0:GHC.Num 099c29dfc2c0e3c154d011e91b663293
import  -/  base-4.8.2.0:GHC.Real da292570a9ba3b498203d266364d0cfe
import  -/  base-4.8.2.0:Prelude 0f9dd1bcfa413fa55bb6dca444292bf6
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
93d200caf6dee15a9fec46a44f406473
  coPrime :: GHC.Real.Integral a => a -> a -> GHC.Types.Bool
  {- Arity: 3,
     Strictness: <S(SLLLLLLLL),U(U,A,A,A,A,C(C1(U)),A,A,A)><L,U><L,U>,
     Unfolding: (\ @ a
                   $dIntegral :: GHC.Real.Integral a
                   eta :: a
                   eta1 :: a ->
                 let {
                   $dReal :: GHC.Real.Real a = GHC.Real.$p1Integral @ a $dIntegral
                 } in
                 GHC.Classes.==
                   @ a
                   (GHC.Classes.$p1Ord @ a (GHC.Real.$p2Real @ a $dReal))
                   (Lib.gcd @ a $dIntegral eta eta1)
                   (GHC.Num.fromInteger
                      @ a
                      (GHC.Real.$p1Real @ a $dReal)
                      Lib.coPrime1)) -}
cfdd8f73c27eea9254b79ff32e973d7a
  coPrime1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
3df76cf0b2503aaa640af3a7bd182531
  gcd :: GHC.Real.Integral a => a -> a -> a
  {- Arity: 3,
     Strictness: <S(SLLLLLLLL),U(U,A,A,A,A,C(C1(U)),A,A,A)><L,U><L,U> -}
df48da60450b8f3ea7283c08f3bf84c6
  gcfList :: GHC.Real.Integral a => [a] -> a
  {- Arity: 2,
     Strictness: <S,U(U,A,A,A,C(C1(U)),C(C1(U)),A,A,A)><S,1*U>,
     Unfolding: (\ @ a $dIntegral :: GHC.Real.Integral a eta :: [a] ->
                 let {
                   $dReal :: GHC.Real.Real a = GHC.Real.$p1Integral @ a $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Real @ a $dReal
                 } in
                 let {
                   z :: a = GHC.Num.fromInteger @ a $dNum Lib.coPrime1
                 } in
                 letrec {
                   go :: [a] -> a {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [a] ->
                     case ds of wild {
                       [] -> z
                       : y ys
                       -> let {
                            y1 :: a = go ys
                          } in
                          GHC.Real.div
                            @ a
                            $dIntegral
                            (GHC.Num.* @ a $dNum y y1)
                            (Lib.gcd @ a $dIntegral y y1) }
                 } in
                 go eta) -}
c6be2290ff138f0c04af16e5b3e22bd9
  list2_1 :: GHC.Real.Integral a => [[a]] -> a
  {- Arity: 2, Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a $dIntegral :: GHC.Real.Integral a eta :: [[a]] ->
                 case eta of wild {
                   [] -> Lib.list2_3 @ a
                   : ipv ipv1
                   -> let {
                        $dReal :: GHC.Real.Real a = GHC.Real.$p1Integral @ a $dIntegral
                      } in
                      let {
                        $dOrd :: GHC.Classes.Ord a = GHC.Real.$p2Real @ a $dReal
                      } in
                      case GHC.Base.map
                             @ [a]
                             @ a
                             (GHC.List.maximum @ a $dOrd)
                             wild of wild1 {
                        [] -> Lib.list2_2 @ a
                        : ipv2 ipv3
                        -> let {
                             k :: a -> a -> a = GHC.Classes.min @ a $dOrd
                           } in
                           letrec {
                             go :: [a] -> a -> a {- Arity: 2, Strictness: <S,1*U><L,U> -}
                             = \ ds :: [a] eta1 :: a ->
                               case ds of wild2 { [] -> eta1 : y ys -> go ys (k eta1 y) }
                           } in
                           go ipv3 ipv2 } }) -}
2f0d3001a928eeb2e562e26a8d7e1d39
  list2_2 :: a
  {- Strictness: b -}
493db491a5707bff0a7865f809f65894
  list2_3 :: a
  {- Strictness: b -}
1215e5a9199baf2a6584f2d34d839847
  perfect :: GHC.Real.Integral a => a -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(LLLLLLC(C(S))L)LLLLLLL),U(U,U(U,U,U,U,U,U,U,U),A,A,A,C(C1(U)),A,A,A)><L,U> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

